# designpattern
designpattern implement with java 

#23种设计模式java实现

## 创建型

- 单例模式
    
    确保一个类只有一个实例，并提供该实例的全局访问点。
- 工厂模式
    - 简单工厂
      
      在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。
    - 工厂方法
    
        定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。
    - 抽象工厂
    
        提供一个接口，用于创建 相关的对象家族 。
- 建造者模式
    
    封装一个对象的构造过程，并允许按步骤构造。
- 原型模式

    使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象

## 行为型
- 责任链模式

    使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。
- 命令模式

    将命令封装成对象中，具有以下作用：
    
    - 使用命令来参数化其它对象
    - 将命令放入队列中进行排队
    - 将命令的操作记录到日志中
    - 支持可撤销的操作
- 解释器模式

    为语言创建解释器，通常由语言的语法和语法分析来定义。

- 迭代器模式
    提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。
- 中介者模式

    集中相关对象之间复杂的沟通和控制方式。
- 备忘录模式

    在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。
- 观察者模式
    
    定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。
    
    主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。
- 状态模式

    允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。

- 策略模式
    
    定义一系列算法，封装每个算法，并使它们可以互换。
    
    策略模式可以让算法独立于使用它的客户端。

- 模板模式

    定义算法框架，并将一些步骤的实现延迟到子类。
    
    通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。
- 访问者模式

    为一个对象结构（比如组合结构）增加新能力。
- 空对象模式

    使用什么都不做
    
    的空对象来代替 NULL。
    
    一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。

## 结构型
- 适配器模式

    把一个类接口转换成另一个用户需要的接口。

- 桥接模式

    将抽象与实现分离开来，使它们可以独立变化。

- 组合模式

    将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。
- 装饰者模式

    为对象动态添加功能。
- 门面模式
    
    提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。

- 享元模式
    
    利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。

- 代理模式
    
    控制对其它对象的访问。
    代理有以下四类：
    
    - 远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。
    - 虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。
    - 保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。
    - 智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。


